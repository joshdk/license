// Copyright 2017 Josh Komoroske. All rights reserved.
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE.txt file.

package main

import (
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"strings"

	"github.com/dave/jennifer/jen"

	"github.com/joshdk/licensor/spdx"
)

func find(root string) chan string {
	jsonDir := path.Join(root, "json")

	detailsDir := path.Join(jsonDir, "details")

	out := make(chan string)

	go func() {
		defer close(out)

		err := filepath.Walk(detailsDir, func(fullPath string, info os.FileInfo, err error) error {
			if path.Ext(fullPath) == ".json" {
				out <- fullPath
			}

			return nil
		})

		if err != nil {
			panic(err)
		}
	}()

	return out
}

func read(in chan string) chan []byte {
	out := make(chan []byte)

	go func() {
		defer close(out)

		for filename := range in {
			contents, err := ioutil.ReadFile(filename)
			if err != nil {
				panic(err)
			}

			out <- contents
		}
	}()

	return out
}

func parse(in chan []byte) chan spdx.License {
	out := make(chan spdx.License)

	go func() {
		defer close(out)

		for body := range in {
			var license spdx.License

			if err := json.Unmarshal(body, &license); err != nil {
				panic(err)

			}

			var uris []string

			for _, uri := range license.URIs {
				uri = strings.TrimSpace(uri)
				if uri != "" {
					uris = append(uris, uri)
				}
			}

			license.URIs = uris

			out <- license
		}
	}()

	return out
}

func render(pkg string, license spdx.License) string {
	f := jen.NewFilePath(pkg)

	// https://github.com/golang/go/issues/13560#issuecomment-277804473
	f.HeaderComment("Code generated by github.com/joshdk/licensor/spdxgen. DO NOT EDIT.")

	lits := make([]jen.Code, len(license.URIs))
	for index, uri := range license.URIs {
		lits[index] = jen.Lit(uri)
	}

	value := jen.Dict{
		jen.Id("Name"):             jen.Lit(license.Name),
		jen.Id("Identifier"):       jen.Lit(license.Identifier),
		jen.Id("Text"):             jen.Lit(license.Text),
		jen.Id("URIs"):             jen.Index().String().Values(lits...),
		jen.Id("StandardTemplate"): jen.Lit(license.StandardTemplate),
		jen.Id("StandardHeader"):   jen.Lit(license.StandardHeader),
		jen.Id("Deprecated"):       jen.Lit(license.Deprecated),
		jen.Id("OSIApproved"):      jen.Lit(license.OSIApproved),
	}

	f.Func().Id("init").Params().Block(
		jen.Id("licenses").Op("=").Append(
			jen.Id("licenses"),
			jen.Qual("github.com/joshdk/licensor/spdx", "License").Values(value),
		),
	)

	return fmt.Sprintf("%#v", f)
}

func pkgDir(pkg string) (string, error) {
	if pkg == "." {
		return os.Getwd()
	}

	gopath, ok := os.LookupEnv("GOPATH")
	if !ok {
		return "", errors.New("no GOPATH set in working environment")
	}

	return filepath.Join(gopath, "src", pkg), nil
}

func generate(spdxDataPkg string, targetPkg string) error {

	// Resolve SPDX license list data package to the correct directory
	spdxDataPkgDir, err := pkgDir(spdxDataPkg)
	if err != nil {
		return err
	}

	// Resolve target package to the correct directory
	targetPkgDir, err := pkgDir(targetPkg)
	if err != nil {
		return err
	}

	licenses := parse(read(find(spdxDataPkgDir)))

	for license := range licenses {

		// Construct a reasonable filename
		targetFilename := fmt.Sprintf("index-%s.gen.go", strings.ToLower(license.Identifier))

		// Name of generated Go source file
		targetFile := filepath.Join(targetPkgDir, targetFilename)

		// render single file contents
		rendered := render(targetPkg, license)

		if err := ioutil.WriteFile(targetFile, []byte(rendered), 0644); err != nil {
			return err
		}
	}

	return nil
}

func main() {

	err := func() error {
		if len(os.Args) < 3 {
			return errors.New("insufficient arguments")
		}

		var (
			spdxDataPkg = os.Args[1]
			targetPkg   = os.Args[2]
		)

		return generate(spdxDataPkg, targetPkg)
	}()

	if err != nil {
		fmt.Fprintf(os.Stderr, "spdxgen: %s", err)
		os.Exit(1)
	}
}
